val pico  = require "pico"

func conn_up_dn (up, dn) {
    var n = 0
    set n = n + match up {
        :machine    => 1
        :pipe.line  => if (up.rot==90) || (up.rot==270) => 1 => 0
        :pipe.curve => if (up.rot==90) || (up.rot==180) => 1 => 0
    }
    set n = n + match dn {
        :machine    => 1
        :pipe.line  => if (dn.rot==90) || (dn.rot==270) => 1 => 0
        :pipe.curve => if (dn.rot== 0) || (dn.rot==270) => 1 => 0
    }
    n
}

func conn_le_ri (le, ri) {
    var n = 0
    set n = n + match le {
        :machine    => 1
        :pipe.line  => if (le.rot==0) || (le.rot==180) => 1 => 0
        :pipe.curve => if (le.rot==0) || (le.rot== 90) => 1 => 0
    }
    set n = n + match ri {
        :machine    => 1
        :pipe.line  => if (le.rot==  0) || (le.rot==180) => 1 => 0
        :pipe.curve => if (ri.rot==180) || (ri.rot==270) => 1 => 0
    }
    n
}

func bounds (this, c, l) {
    match this {
        :machine   => true
        :pipe.line => match this.rot {
            0   => (c >= 1) && (c <= (w-2))
            180 => (c >= 1) && (c <= (w-2))
            90  => (l >= 1) && (l <= (h-2))
            270 => (l >= 1) && (l <= (h-2))
        }
        :pipe.curve => match this.rot {
            0   => (l >= 1)     && (c <= (w-2))
            90  => (l <= (h-2)) && (c <= (w-2))
            180 => (c >= 1)     && (l <= (h-2))
            270 => (c >= 1)     && (l >= 1)
        }
    }
}

func check (this, c, l) {
    ifs {
        (c < 0) || (c >= w) => false    ;; out of screen
        (l < 0) || (l >= h) => false    ;; out of screen
        MAP[l+1][c+1]       => false    ;; existing piece
        !bounds(this, c, l) => false    ;; connections in the bounds
        else => {
            val up = (l > 0)     && MAP[l][c+1]     ;; piece on each
            val dn = (l < (h-1)) && MAP[l+2][c+1]   ;; direction
            val le = (c > 0)     && MAP[l+1][c]
            val ri = (c < (w-1)) && MAP[l+1][c+2]
            val mm = (this ?? :machine) && (
                (up ?? :machine) ||
                (dn ?? :machine) ||
                (le ?? :machine) ||
                (ri ?? :machine)
            )
            if mm {
                false   ;; machine <-> machine
            } else {
                val n1 = if up => conn_up_dn(up, this) => 0
                val n2 = if dn => conn_up_dn(this, dn) => 0
                val n3 = if le => conn_le_ri(le, this) => 0
                val n4 = if ri => conn_le_ri(this, ri) => 0
                (this !? :pipe) || ((n1+n2+n3+n4) >= 2)
            }
        }
    }
}

func Float (this) {
    watching :mouse.button.dn, :right {
        spawn {
            val no = pico.color.red -> X.copy
            set no.a = 0x99
            every :draw {
                val lc  = pico.get.mouse() -> pos_lc
                val pos = lc -> lc_pos
                pico.zet.anchor.pos(:top, :left)
                pico.zet.rotate(this.rot)
                pico.output.draw.buffer(pos, this.img)
                if !check(this, lc.c, lc.l) {
                    pico.zet.color.draw(no)
                    pico.output.draw.rect @{
                        x=pos.x, y=pos.y, w=R, h=R
                    }
                }
                pico.zet.rotate(0)
                pico.zet.anchor.pos(:center, :middle)
            }
        }
        loop {
            await(:mouse.button.dn, :left)
            val e = watching @.200 {
                await(:mouse.button.dn, :left)
                val lc = pico.get.mouse() -> pos_lc
                if check(this, lc.c, lc.l) {
                    set MAP[lc.l+1][lc.c+1] = this
                    return()  ;; piece placed
                }
            }
            if e == :clock {
                set this.rot = (this.rot + 90) % 360
            }
        }
    }
    ;; piece displaced
}

Float
