val pico  = require "pico"

func ends (this) {
    val aux = func (l, c) {
        ifs {
            (c < 0) || (c == w) => @{}
            (l < 0) || (l == h) => @{}
            else => MAP[l+1][c+1] -> \{ if it => @{it} => @{} }
        }
    }
    val l, c = (this.l, this.c)
    match this {
        :machine => aux(l-1,c) ++ aux(l+1,c) ++ aux(l,c-1) ++ aux(l,c+1)
        :pipe.line => match this.rot {
            0   => aux(l,c-1) ++ aux(l,c+1)
            180 => aux(l,c-1) ++ aux(l,c+1)
            90  => aux(l-1,c) ++ aux(l+1,c)
            270 => aux(l-1,c) ++ aux(l+1,c)
        }
        :pipe.curve => match this.rot {
            0   => aux(l-1,c) ++ aux(l,c+1)
            90  => aux(l+1,c) ++ aux(l,c+1)
            180 => aux(l,c-1) ++ aux(l+1,c)
            270 => aux(l-1,c) ++ aux(l,c-1)
        }
        :io.input => match this.rot {
            0   => aux(l,c+1)
            90  => aux(l+1,c)
            180 => aux(l,c-1)
            270 => aux(l-1,c)
        }
        :io.output => match this.rot {
            0   => aux(l,c-1)
            90  => aux(l-1,c)
            180 => aux(l,c+1)
            270 => aux(l+1,c)
        }
    }
}

test {
    set w = 3
    set h = 3

    set v00 = :machine    @{ l=0, c=0, rot=0   }
    set v01 = :pipe.line  @{ l=0, c=1, rot=0   }
    set v02 = :pipe.curve @{ l=0, c=2, rot=180 }

    set v10 = :pipe.curve @{ l=1, c=0, rot=0   }
    set v11 = :pipe.curve @{ l=1, c=1, rot=180 }
    set v12 = :pipe.line  @{ rot=90 } ;; not in MAP

    set v21 = :machine    @{ l=2, c=1, rot=0 }
    set v22 = :pipe.curve @{ l=2, c=2, rot=270 }

    set MAP = @{
        @{ v00, v01, v02 },
        @{ v10, v11, nil },
        @{ nil, v21, v22 },
    }

    do {    ;; v00
        val x,y = v00->ends() --> table.unpack
        assert((x == v10) && (y == v01))
    }
    do {    ;; v01
        val x,y = v01->ends() --> table.unpack
        assert((x == v00) && (y == v02))
    }
    do {    ;; v11
        val x,y = v11->ends() --> table.unpack
        assert((x == v10) && (y == v21))
    }
    do {    ;; v12
        set v12.l = 1
        set v12.c = 2
        val x,y = v12->ends() --> table.unpack
        assert((x == v02) && (y == v22))
        set v12.l = nil
        set v12.c = nil
    }
}

func _cycle_ (src, cur, nxt) {
    if src == nxt {
        true
    } else {
        loop _,v in nxt->ends() {
            if v != cur {
                if _cycle_(src, nxt, v) {
                    return(true)
                }
            }
        }
        false
    }
}

;; Ensures that the (max) two endpoints of `this` are not connected.

func cycle (this, l, c) {
    set this.l = l
    set this.c = c
    defer {
        set this.l = nil
        set this.c = nil
    }
    match this {
        :machine => false
        :io      => false
        :pipe    => {
            val src, dst = this->ends() --> table.unpack
            (dst != nil) && _cycle_(src, nil, dst)
        }
    }
}

test {
    _cycle_(v00, nil, v00) --> assert
    _cycle_(v02, nil, v00) --> assert
    cycle(v12, 1, 2) --> assert
}

func conn_up_dn (up, dn) {
    val xup = match up {
        :machine    => 1
        :pipe.line  => (up.rot==90) || (up.rot==270)
        :pipe.curve => (up.rot==90) || (up.rot==180)
        :io.input   => (up.rot == 90)
        :io.output  => (up.rot == 270)
    }
    val xdn = match dn {
        :machine    => 1
        :pipe.line  => (dn.rot==90) || (dn.rot==270)
        :pipe.curve => (dn.rot== 0) || (dn.rot==270)
        :io.input   => (up.rot == 270)
        :io.output  => (up.rot == 90)
    }
    (xup && xdn)
}

func conn_le_ri (le, ri) {
    val xle = match le {
        :machine    => true
        :pipe.line  => (le.rot==0) || (le.rot==180)
        :pipe.curve => (le.rot==0) || (le.rot== 90)
        :io.input   => (up.rot == 0)
        :io.output  => (up.rot == 180)
    }
    val xri = match ri {
        :machine    => true
        :pipe.line  => (le.rot==  0) || (le.rot==180)
        :pipe.curve => (ri.rot==180) || (ri.rot==270)
        :io.input   => (up.rot == 180)
        :io.output  => (up.rot == 0)
    }
    (xle && xri)
}

func bounds (this, l, c) {
    match this {
        :machine   => true
        :pipe.line => match this.rot {
            0   => (c >= 1) && (c <= (w-2))
            180 => (c >= 1) && (c <= (w-2))
            90  => (l >= 1) && (l <= (h-2))
            270 => (l >= 1) && (l <= (h-2))
        }
        :pipe.curve => match this.rot {
            0   => (l >= 1)     && (c <= (w-2))
            90  => (l <= (h-2)) && (c <= (w-2))
            180 => (c >= 1)     && (l <= (h-2))
            270 => (c >= 1)     && (l >= 1)
        }
    }
}

func check (this, c, l) {
    ifs {
        (c < 0) || (c >= w) => false    ;; out of screen
        (l < 0) || (l >= h) => false    ;; out of screen
        MAP[l+1][c+1]       => false    ;; existing piece
        !bounds(this, l, c) => false    ;; connections in the bounds
        cycle(this, l, c)   => false    ;; cycle detected
        else => {
            val up = (l > 0)     && MAP[l][c+1]     ;; piece on each
            val dn = (l < (h-1)) && MAP[l+2][c+1]   ;; direction
            val le = (c > 0)     && MAP[l+1][c]
            val ri = (c < (w-1)) && MAP[l+1][c+2]
            val mm = (this ?? :machine) && (
                (up ?? :machine) ||
                (dn ?? :machine) ||
                (le ?? :machine) ||
                (ri ?? :machine)
            )
            if mm {
                false   ;; machine <-> machine
            } else {
                val n1 = up && conn_up_dn(up,this)
                val n2 = dn && conn_up_dn(this,dn)
                val n3 = le && conn_le_ri(le,this)
                val n4 = ri && conn_le_ri(this,ri)
                (this !? :pipe) || (n1||n2||n3||n4)
            }
        }
    }
}

func Float (this) {
    watching :mouse.button.dn, :right {
        spawn {
            val no = pico.color.red -> X.copy
            set no.a = 0x99
            every :draw {
                val lc  = pico.get.mouse() -> pos_lc
                val pos = lc -> lc_pos
                pico.zet.anchor.pos(:top, :left)
                pico.zet.rotate(this.rot)
                pico.output.draw.buffer(pos, this.img)
                if !check(this, lc.c, lc.l) {
                    pico.zet.color.draw(no)
                    pico.output.draw.rect @{
                        x=pos.x, y=pos.y, w=R, h=R
                    }
                }
                pico.zet.rotate(0)
                pico.zet.anchor.pos(:center, :middle)
            }
        }
        loop {
            await(:mouse.button.dn, :left)
            val e = watching @.200 {
                await(:mouse.button.dn, :left)
                val lc = pico.get.mouse() -> pos_lc
                if check(this, lc.c, lc.l) {
                    set this.l = lc.l
                    set this.c = lc.c
                    set MAP[lc.l+1][lc.c+1] = this
                    return()  ;; piece placed
                }
            }
            if e == :clock {
                set this.rot = (this.rot + 90) % 360
            }
        }
    }
    ;; piece displaced
}

Float
