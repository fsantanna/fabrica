val pico = require "pico"
val art  = require "art"

val func ends (this) {
    val func aux (l, c) {
        ifs {
            (c < 0) || (c == w) => @{}
            (l < 0) || (l == h) => @{}
            else => MAP[l+1][c+1] -> \{ if it => @{it} => @{} }
        }
    }
    val l, c = (this.l, this.c)
    match this {
        :machine => aux(l-1,c) ++ aux(l+1,c) ++ aux(l,c-1) ++ aux(l,c+1)
        :pipe.line => match this.rot {
            0   => aux(l,c-1) ++ aux(l,c+1)
            180 => aux(l,c-1) ++ aux(l,c+1)
            90  => aux(l-1,c) ++ aux(l+1,c)
            270 => aux(l-1,c) ++ aux(l+1,c)
        }
        :pipe.curve => match this.rot {
            0   => aux(l-1,c) ++ aux(l,c+1)
            90  => aux(l+1,c) ++ aux(l,c+1)
            180 => aux(l,c-1) ++ aux(l+1,c)
            270 => aux(l-1,c) ++ aux(l,c-1)
        }
        :io.input => match this.rot {
            0   => aux(l,c+1)
            90  => aux(l+1,c)
            180 => aux(l,c-1)
            270 => aux(l-1,c)
        }
        :io.output => match this.rot {
            0   => aux(l,c-1)
            90  => aux(l-1,c)
            180 => aux(l,c+1)
            270 => aux(l+1,c)
        }
    }
}

test {
    set w = 3
    set h = 3

    set v00 = :machine    @{ l=0, c=0, rot=0   }
    set v01 = :pipe.line  @{ l=0, c=1, rot=0   }
    set v02 = :pipe.curve @{ l=0, c=2, rot=180 }

    set v10 = :pipe.curve @{ l=1, c=0, rot=0   }
    set v11 = :pipe.curve @{ l=1, c=1, rot=180 }
    set v12 = :pipe.line  @{ rot=90 } ;; not in MAP

    set v21 = :machine    @{ l=2, c=1, rot=0 }
    set v22 = :pipe.curve @{ l=2, c=2, rot=270 }

    set MAP = @{
        @{ v00, v01, v02 },
        @{ v10, v11, nil },
        @{ nil, v21, v22 },
    }

    do {    ;; v00
        val x,y = v00->ends() --> table.unpack
        assert((x == v10) && (y == v01))
    }
    do {    ;; v01
        val x,y = v01->ends() --> table.unpack
        assert((x == v00) && (y == v02))
    }
    do {    ;; v11
        val x,y = v11->ends() --> table.unpack
        assert((x == v10) && (y == v21))
    }
    do {    ;; v12
        set v12.l = 1
        set v12.c = 2
        val x,y = v12->ends() --> table.unpack
        assert((x == v02) && (y == v22))
        set v12.l = nil
        set v12.c = nil
    }
}

val func _cycle_ (src, cur, nxt) {
    if src == nxt {
        true
    } else {
        loop _,v in nxt->ends() {
            if v != cur {
                if _cycle_(src, nxt, v) {
                    return(true)
                }
            }
        }
        false
    }
}

;; Ensures that the (max) two endpoints of `this` are not connected.

val func cycle (this, l, c) {
    set this.l = l
    set this.c = c
    defer {
        set this.l = nil
        set this.c = nil
    }
    match this {
        :machine => false
        :io      => false
        :pipe    => {
            val src, dst = this->ends() --> table.unpack
            (dst != nil) && _cycle_(src, nil, dst)
        }
    }
}

test {
    _cycle_(v00, nil, v00) --> assert
    _cycle_(v02, nil, v00) --> assert
    cycle(v12, 1, 2) --> assert
}

val func conn_up_dn (up, dn) {
    val xup = match up {
        :machine    => 1
        :pipe.line  => (up.rot==90) || (up.rot==270)
        :pipe.curve => (up.rot==90) || (up.rot==180)
        :io.input   => (up.rot == 90)
        :io.output  => (up.rot == 270)
    }
    val xdn = match dn {
        :machine    => 1
        :pipe.line  => (dn.rot==90) || (dn.rot==270)
        :pipe.curve => (dn.rot== 0) || (dn.rot==270)
        :io.input   => (dn.rot == 270)
        :io.output  => (dn.rot == 90)
    }
    (xup && xdn)
}

val func conn_le_ri (le, ri) {
    val xle = match le {
        :machine    => true
        :pipe.line  => (le.rot==0) || (le.rot==180)
        :pipe.curve => (le.rot==0) || (le.rot== 90)
        :io.input   => (le.rot == 0)
        :io.output  => (le.rot == 180)
    }
    val xri = match ri {
        :machine    => true
        :pipe.line  => (ri.rot==  0) || (ri.rot==180)
        :pipe.curve => (ri.rot==180) || (ri.rot==270)
        :io.input   => (ri.rot == 180)
        :io.output  => (ri.rot == 0)
    }
    (xle && xri)
}

val func bounds (this, l, c) {
    match this {
        :machine   => true
        :pipe.line => match this.rot {
            0   => (c >= 1) && (c <= (w-2))
            180 => (c >= 1) && (c <= (w-2))
            90  => (l >= 1) && (l <= (h-2))
            270 => (l >= 1) && (l <= (h-2))
        }
        :pipe.curve => match this.rot {
            0   => (l >= 1)     && (c <= (w-2))
            90  => (l <= (h-2)) && (c <= (w-2))
            180 => (c >= 1)     && (l <= (h-2))
            270 => (c >= 1)     && (l >= 1)
        }
        :io => true ;; never open
    }
}

val func compat (v1, v2) {
    ifs {
        (v1 ?? :machine) => true
        (v2 ?? :machine) => true
        (v1 ?? :pipe)    => (v2 ?? :pipe)
        else             => false
    }
}

val func check (this, c, l) {
    ifs {
        (c < 0) || (c >= w) => false    ;; out of screen
        (l < 0) || (l >= h) => false    ;; out of screen
        MAP[l+1][c+1]       => false    ;; existing piece
        !bounds(this, l, c) => false    ;; connections in the bounds
        cycle(this, l, c)   => false    ;; cycle detected
        (this ?? :machine)  => true     ;; no connection required
        (this ?? :io.output) && (this.picker.i == -1) => false ;; pending color
        else => {
            val up = (l > 0)     && MAP[l][c+1]     ;; piece on each
            val dn = (l < (h-1)) && MAP[l+2][c+1]   ;; direction
            val le = (c > 0)     && MAP[l+1][c]
            val ri = (c < (w-1)) && MAP[l+1][c+2]
            ifs {
                up && compat(this,up) && conn_up_dn(up,this) => true
                dn && compat(this,dn) && conn_up_dn(this,dn) => true
                le && compat(this,le) && conn_le_ri(le,this) => true
                ri && compat(this,ri) && conn_le_ri(this,ri) => true
                else => false
            }
        }
    }
}

val func Float (this) {
    set this.img = match this.clr {
        :black  => this.img
        :player => {
            set this.clr = PLAYERS.active
            this.img->art.paint(pico.color[PLAYERS.active])
        }
        else => {
            set this.picker = @{ i=-1 }      ;; -1: color picker unset (invalid)
            loop i,c in art.juices {
                set this.picker[i] = @{
                    clr = c,
                    img = this.img->art.paint(pico.color[c]),
                }
            }
            this.img
        }
    }

    watching :key.dn, :Escape {
        par {
            val no = pico.color.red -> X.copy
            set no.a = 0x88
            every :draw {
                val lc  = pico.get.mouse() -> pos_lc
                val pos = lc -> lc_pos
                pico.zet.anchor.pos(:top, :left)
                pico.zet.rotate(this.rot)
                pico.output.draw.buffer(pos, this.img)
                if !check(this, lc.c, lc.l) {
                    pico.zet.color.draw(no)
                    pico.zet.style(:stroke)
                    pico.output.draw.rect @{
                        x=pos.x, y=pos.y, w=R, h=R
                    }
                }
                pico.zet.rotate(0)
                pico.zet.anchor.pos(:center, :middle)
            }
        } with {
            if this.picker != nil {
                loop {
                    await(:mouse.button.dn, :right)
                    set this.picker.i = (this.picker.i + 1) % #this.picker
                    set this.img = this.picker[this.picker.i+1].img
                }
            }
        } with {
            loop {
                val n = await Clicks(:left)
                match n {
                    1 => {
                        set this.rot = (this.rot + 90) % 360
                    }
                    2 => {
                        val lc = pico.get.mouse() -> pos_lc
                        if check(this, lc.c, lc.l) {
                            set this.l = lc.l
                            set this.c = lc.c
                            set MAP[lc.l+1][lc.c+1] = this
                            if this.clr == :picker {
                                set this.clr = this.picker[this.picker.i+1].clr
                            }
                            return()  ;; piece placed
                        }
                    }
                }
            }
        }
    }
    ;; piece displaced
}

Float
