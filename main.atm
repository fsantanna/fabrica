require "atmos.env.pico"

set X     = require "atmos.x"
val pico  = require "pico"
val art   = require "art"
val Panel = require "panel"

set W = 120
set H = 120
set R = 6
set w = W/R
set h = H/R

pico.zet.title("Fábrica");
pico.zet.size.window(@{x=R*W,y=R*H}, @{x=W,y=H})
pico.zet.expert(true);

set MAP = @{}
loop l in h {
    set MAP[l] = @{}
    loop c in w {
        set MAP[l][c] = nil     ;; { img=buffer, rot=degrees }
    }
}

math.randomseed()

spawn {
    every :draw {
        loop l in h {
            loop c in w {
                val t = MAP[l][c]
                if t {
                    val pos = @{ x=(c-1)*R, y=(l-1)*R }
                    pico.zet.anchor.draw(:left, :top)
                    pico.zet.rotate(t.rot)
                    pico.output.draw.buffer(pos, t.img)
                    pico.zet.rotate(0)
                }
            }
        }
    }
}

spawn Panel()

pin hand = tasks(1)     ;; somente 1 peça "na mão" por vez
set HAND = hand         ;; torna mão uma global

func Piece (this) {
    spawn {
        every :draw {
            pico.zet.anchor.draw(:center, :middle)
            pico.zet.rotate(this.rot)
            pico.output.draw.buffer(pico.get.mouse(), this.img)
            pico.zet.rotate(0)
        }
    }
    do :ok {
        loop {
            await :mouse.button.dn
            watching @.200 {
                await :mouse.button.dn
                escape :ok
            }
            set this.rot = this.rot + 90
        }
    }
    val pos = pico.get.mouse()
    val l = pos.y // R
    val c = pos.x // R
    set MAP[l+1][c+1] = this
}

await(false)
