require "atmos.env.pico"

set X     = require "atmos.x"
val pico  = require "pico"
val art   = require "art"
val Panel = require "panel"

set R = 6
set w = 15
set h = 15
set W = R*w
set H = R*(h+2)

pico.zet.title("Fábrica");
pico.zet.dim.window(R*W, R*H)
pico.zet.dim.world(W, H)
pico.zet.expert(true);

func pos_lc (pos) {
    @{
        l = pos.y // R,
        c = pos.x // R,
    }
}

func lc_pos (lc) {
    @{
        x = lc.c * R,
        y = lc.l * R,
    }
}

set MAP = @{}
loop l in h {
    set MAP[l] = @{}
    loop c in w {
        set MAP[l][c] = nil     ;; { img=buffer, rot=degrees }
    }
}

math.randomseed()

spawn {
    every :draw {
        loop l in h {
            loop c in w {
                val t = MAP[l][c]
                if t {
                    val pos = @{ l=l-1, c=c-1 } -> lc_pos
                    pico.zet.anchor.pos(:left, :top)
                    pico.zet.rotate(t.rot)
                    pico.output.draw.buffer(pos, t.img)
                    pico.zet.rotate(0)
                    pico.zet.anchor.pos(:center, :middle)
                }
            }
        }
    }
}

val r = @{ x=W/2, y=H-R, w=W, h=2*R }
spawn Panel(r)

pin hand = tasks(1)     ;; somente 1 peça "na mão" por vez
set HAND = hand         ;; torna mão uma global

func conn_up_dn (up, dn) {
    var n = 0
    set n = n + match up.img {
        art.pipe.straight => if (up.rot==90) || (up.rot==270) => 1 => 0
        art.pipe.curve    => if (up.rot==90) || (up.rot==180) => 1 => 0
    }
    set n = n + match dn.img {
        art.pipe.straight => if (dn.rot==90) || (dn.rot==270) => 1 => 0
        art.pipe.curve    => if (dn.rot== 0) || (dn.rot==270) => 1 => 0
    }
    (n != 1)
}

func conn_le_ri (le, ri) {
    var n = 0
    set n = n + match le.img {
        art.pipe.straight => if (le.rot==90) || (le.rot==270) => 0 => 1
        art.pipe.curve    => if (le.rot== 0) || (le.rot== 90) => 0 => 1
    }
    set n = n + match ri.img {
        art.pipe.straight => if (ri.rot== 90) || (ri.rot==270) => 1 => 0
        art.pipe.curve    => if (ri.rot==180) || (ri.rot==270) => 1 => 0
    }
    (n != 1)
}

func check (this, c, l) {
    ifs {
        (c < 0) || (c >= w) => false    ;; out of screen
        (l < 0) || (l >= h) => false    ;; out of screen
        MAP[l+1][c+1]       => false    ;; existing piece
        else => {
            val up = (l > 0)     && MAP[l][c+1]     ;; piece on each
            val dn = (l < (h-1)) && MAP[l+2][c+1]   ;; direction
            val le = (c > 0)     && MAP[l+1][c]
            val ri = (c < (w-1)) && MAP[l+1][c+2]
            ifs {
                (up && !conn_up_dn(up, this)) => false
                (dn && !conn_up_dn(this, dn)) => false
                (le && !conn_le_ri(le, this)) => false
                (ri && !conn_le_ri(this, ri)) => false
                else => true
            }
        }
    }
}

func Piece (this) {
    watching :mouse.button.dn, :right {
        spawn {
            val no = pico.color.red -> X.copy
            set no.a = 0x99
            every :draw {
                val lc  = pico.get.mouse() -> pos_lc
                val pos = lc -> lc_pos
                pico.zet.anchor.pos(:top, :left)
                pico.zet.rotate(this.rot)
                pico.output.draw.buffer(pos, this.img)
                if !check(this, lc.c, lc.l) {
                    pico.zet.color.draw(no)
                    pico.output.draw.rect @{
                        x=pos.x, y=pos.y, w=R, h=R
                    }
                }
                pico.zet.rotate(0)
                pico.zet.anchor.pos(:center, :middle)
            }
        }
        loop {
            await(:mouse.button.dn, :left)
            val e = watching @.200 {
                await(:mouse.button.dn, :left)
                val lc = pico.get.mouse() -> pos_lc
                if check(this, lc.c, lc.l) {
                    set MAP[lc.l+1][lc.c+1] = this
                    return()  ;; piece placed
                }
            }
            if e == :clock {
                set this.rot = (this.rot + 90) % 360
            }
        }
    }
    ;; piece displaced
}

await(false)
