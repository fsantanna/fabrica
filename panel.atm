val pico  = require "pico"
val art   = require "art"
val Float = require "float"

val colors = @{
    [:machine]     = true,
    [:pipe.line]   = false,
    [:pipe.curve]  = false,
    [:pipe.input]  = false,
    [:pipe.output] = @{
        ...
    },
}

func Tile (tag, pos, img) {
    par {
        every :draw {
            pico.output.draw.buffer(pos, img.black)
        }
    } with {
        var rect = @{ x=pos.x, y=pos.y, w=R, h=R }
        loop {
            val m = await(:mouse.button.dn, :left, \{pico.vs.pos_rect(it,rect)})
            watching @.200 {
                await(:mouse.button.dn, :left, \{pico.vs.pos_rect(it,rect)})
                spawn [HAND] Float @{ tag=tag, img=img, rot=0, clr=colors[tag] }
            }
        }
    }
}

func Panel (r) {
    val io = pico.rect(@{x=25,y=50}, @{x=30,y=80}, r)
    val ps = pico.rect(@{x=75,y=50}, @{x=30,y=80}, r)
    par {
        every :draw {
            pico.zet.clip(r)
            pico.zet.color.clear(pico.color.white)
            ;;pico.push @{}
            pico.output.clear()
            pico.zet.color.draw(pico.color.black)
            pico.zet.style(:stroke)
            pico.output.draw.rect(io)
            pico.output.draw.rect(ps)
            pico.zet.style(:fill)
        }
    } with {
        spawn Tile(:io.input,   pico.pos(@{x=33,y=50}, io), art.io.input)
        spawn Tile(:io.output,  pico.pos(@{x=67,y=50}, io), art.io.output)
        spawn Tile(:machine,    pico.pos(@{x=50,y=50}, r),  art.machine)
        spawn Tile(:pipe.line,  pico.pos(@{x=33,y=50}, ps), art.pipe.line)
        spawn Tile(:pipe.curve, pico.pos(@{x=67,y=50}, ps), art.pipe.curve)
        await(false)
    } with {
        every :draw {
            pico.zet.color.clear(pico.color.black)
            pico.zet.clip()
            ;; pico.pop()
        }
    }
}

Panel
